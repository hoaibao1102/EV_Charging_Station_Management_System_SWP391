import React, { useEffect, useState, useCallback, memo } from "react";
import { useNavigate, useLocation, useParams } from "react-router-dom";
import paths from "../../path/paths.jsx";
import { toast } from "react-toastify";
import { stationAPI } from "../../api/stationApi.js";
import { getMySessions } from "../../api/driverApi.js";
import { isAuthenticated } from "../../utils/authUtils.js";

// Import separated modules
import { CHARGING_EFFICIENCY, statusColors } from './chargingSessionConstants.js';
import { getBatteryCapacity, round2, extractPowerKW, syncSessionFromBackend, initChargingSessionStyles } from './chargingSessionUtils.js';
import BatteryProgressCircle from './BatteryProgressCircle.jsx';
import InfoCard from './InfoCard.jsx';
import { useChargingSessionPolling } from './useChargingSessionPolling.js';
import { useChargingSimulation } from './useChargingSimulation.js';
  const capacity = sessionStorage.getItem("batteryCapacityKWh");
  return capacity ? parseFloat(capacity) : 60; // Default to 60 kWh if not found
};
console.log(`üîã Using battery capacity: ${getBatteryCapacity()} kWh`);
// ========== HELPER FUNCTIONS ==========

// üìê Helper: Backend's round2 function (rounds to 2 decimal places)
const round2 = (value) => {
  return Math.round(value * 100.0) / 100.0;
};

// üìê T√≠nh to√°n SOC v√† energy theo c√¥ng th·ª©c CH√çNH X√ÅC c·ªßa Backend
// Backend logic (ChargingSessionTxHandler.java line 159):
//   double deltaSoc = finalSoc - initialSoc;
//   double energyKWh = round2((deltaSoc / 100.0) * batteryCapacity);
//
// Frontend simulation approach:
//   1. Estimate SOC increase from time + power + efficiency
//   2. Calculate energy from deltaSoc (matching Backend)`
const calculateChargingMetrics = ({
  startTime,
  initialSoc,
  powerKW,
  capacity = getBatteryCapacity(),
  efficiency = CHARGING_EFFICIENCY,
}) => {
  const now = new Date();
  const start = new Date(startTime);
  const durationMs = now - start;
  const durationMinutes = durationMs / (1000 * 60);
  const hours = durationMinutes / 60;

  // Step 1: Estimate energy delivered using time-based physics
  // This is for SOC estimation only (not final energy value)
  const estimatedEnergyDelivered = hours * powerKW * efficiency;

  // Step 2: Convert to SOC increase (for simulation display)
  const estimatedSocIncrease = (estimatedEnergyDelivered / capacity) * 100.0;
  let rawFinalSOC = initialSoc + estimatedSocIncrease;

  // Minimum 1% increase if charging for any duration
  if (durationMinutes > 0 && Math.floor(rawFinalSOC) === initialSoc) {
    rawFinalSOC = initialSoc + 1;
  }

  // Clamp to [initialSoc, 100] and round to integer (Backend uses integer SOC)
  let finalSOC = Math.round(rawFinalSOC);
  finalSOC = Math.min(100, Math.max(initialSoc, finalSOC));

  // Step 3: Calculate energy EXACTLY like Backend
  // Backend: energyKWh = round2((deltaSoc / 100.0) * batteryCapacity)
  const deltaSoc = finalSOC - initialSoc;
  const energyKWh = round2((deltaSoc / 100.0) * capacity);

  return {
    finalSOC,
    energyKWh,
    durationMinutes,
  };
};

// ‚ö° Helper ƒë·ªÉ l·∫•y maxPowerKW t·ª´ nhi·ªÅu ngu·ªìn (chu·∫©n h√≥a)
const extractPowerKW = (session, bookingId) => {
  // 1. Try sessionStorage first (saved during booking)
  if (bookingId) {
    try {
      const key = `booking_${bookingId}_maxPowerKW`;
      const storedPower = sessionStorage.getItem(key);
      if (storedPower) {
        const power = JSON.parse(storedPower);
        console.log(`‚úÖ Retrieved maxPowerKW=${power} from sessionStorage`);
        return power;
      }
    } catch (e) {
      console.debug("Failed to retrieve maxPowerKW from sessionStorage:", e);
    }
  }

  // 2. Fallback to session data
  const power =
    session?.chargingPoint?.maxPowerKW ??
    session?.maxPowerKW ??
    session?.ratedKW ??
    session?.powerKW ??
    11.0; // Default

  console.log(`üîç Extracted maxPowerKW=${power} from session data`);
  return power;
};

// üîÑ Helper ƒë·ªÉ sync d·ªØ li·ªáu t·ª´ backend response v√†o session state
const syncSessionFromBackend = (backendData, currentState = {}) => {
  return {
    ...currentState,
    ...backendData,
    status: backendData.status ?? currentState.status,
    endTime: backendData.endTime ?? currentState.endTime,
    finalSoc: backendData.finalSoc ?? currentState.finalSoc,
    energyKWh: backendData.energyKWh ?? currentState.energyKWh,
    cost: backendData.cost ?? currentState.cost,
    durationMinutes:
      backendData.durationMinutes ?? currentState.durationMinutes,
    virtualSoc: backendData.finalSoc ?? currentState.virtualSoc,
    pointNumber: backendData.pointNumber ?? currentState.pointNumber,
    stationName: backendData.stationName ?? currentState.stationName,
    vehiclePlate: backendData.vehiclePlate ?? currentState.vehiclePlate,
    pricePerKWh: backendData.pricePerKWh ?? currentState.pricePerKWh,
    currency: backendData.currency ?? currentState.currency,
  };
};

// Add responsive styles to document
const styleSheet = document.createElement("style");
styleSheet.textContent = `
  @media (max-width: 768px) {
    .charging-session-container {
      padding: 10px !important;
    }
    .battery-progress-circle {
      width: 180px !important;
      height: 180px !important;
    }
    .battery-progress-circle svg {
      width: 180px !important;
      height: 180px !important;
    }
    .battery-progress-circle .center-text {
      font-size: 36px !important;
    }
    .info-card-grid {
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)) !important;
    }
    .quick-info-grid {
      grid-template-columns: 1fr !important;
    }
  }
`;
if (!document.head.querySelector("style[data-charging-session-styles]")) {
  styleSheet.setAttribute("data-charging-session-styles", "true");
  document.head.appendChild(styleSheet);
}

// Battery Progress Circle Component - Enhanced with Smooth Animation
const BatteryProgressCircle = memo(function BatteryProgressCircle({
  initialSoc,
  energyKWh,
  capacity,
  isCharging,
  virtualSoc, // Virtual SOC from physics-based estimation
}) {
  // Use virtual SOC if available (for smooth animation), otherwise calculate from energy
  const deltaPercent = (energyKWh / capacity) * 100;
  const calculatedSoc = Math.min(initialSoc + deltaPercent, 100);
  const currentSoc = virtualSoc ?? calculatedSoc;
  const isComplete = currentSoc >= 100;

  // ‚ú® Smooth SOC animation (interpolation from old to new value)
  const [animatedSoc, setAnimatedSoc] = useState(currentSoc);

  useEffect(() => {
    const diff = currentSoc - animatedSoc;
    if (Math.abs(diff) < 0.1) {
      setAnimatedSoc(currentSoc);
      return;
    }

    const step = diff / 20; // 20 frames for smooth transition
    const interval = setInterval(() => {
      setAnimatedSoc((prev) => {
        const next = prev + step;
        if (
          (diff > 0 && next >= currentSoc) ||
          (diff < 0 && next <= currentSoc)
        ) {
          clearInterval(interval);
          return currentSoc;
        }
        return next;
      });
    }, 50); // Update every 50ms

    return () => clearInterval(interval);
  }, [currentSoc, animatedSoc]);

  // SVG circle parameters - using animatedSoc for smooth fill
  const size = 240;
  const strokeWidth = 16;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const offset = circumference - (animatedSoc / 100) * circumference;

  // Colors
  const progressColor = isComplete ? "#2196f3" : "#00BFA6";
  const trackColor = "#e0e0e0";

  return (
    <div
      className="battery-progress-circle"
      style={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        padding: "30px 20px",
        background: "linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)",
        borderRadius: "20px",
        boxShadow: "0 4px 20px rgba(0,0,0,0.08)",
        margin: "0 auto 30px",
        maxWidth: "400px",
      }}
    >
      {/* Battery Icon Header */}
      <div
        style={{
          fontSize: "48px",
          marginBottom: "15px",
          animation:
            isCharging && !isComplete
              ? "pulse 2s ease-in-out infinite"
              : "none",
        }}
      >
        üîã
      </div>

      {/* SVG Circle */}
      <div style={{ position: "relative", marginBottom: "20px" }}>
        <svg
          width={size}
          height={size}
          style={{
            transform: "rotate(-90deg)",
            filter: "drop-shadow(0 2px 8px rgba(0,191,166,0.3))",
          }}
        >
          {/* Background track */}
          <circle
            cx={size / 2}
            cy={size / 2}
            r={radius}
            stroke={trackColor}
            strokeWidth={strokeWidth}
            fill="none"
          />
          {/* Progress arc */}
          <circle
            cx={size / 2}
            cy={size / 2}
            r={radius}
            stroke={progressColor}
            strokeWidth={strokeWidth}
            fill="none"
            strokeDasharray={circumference}
            strokeDashoffset={offset}
            strokeLinecap="round"
            style={{
              transition:
                "stroke-dashoffset 0.8s cubic-bezier(0.4, 0, 0.2, 1), stroke 0.3s ease",
            }}
          />
        </svg>

        {/* Center text */}
        <div
          style={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            textAlign: "center",
          }}
        >
          <div
            style={{
              fontSize: "48px",
              fontWeight: "800",
              color: progressColor,
              lineHeight: "1",
              marginBottom: "5px",
            }}
          >
            {animatedSoc.toFixed(0)}%
          </div>
          <div
            style={{
              fontSize: "13px",
              color: "#666",
              fontWeight: "500",
              textTransform: "uppercase",
              letterSpacing: "0.5px",
            }}
          >
            Pin hi·ªán t·∫°i
          </div>
        </div>
      </div>

      {/* Caption */}
      <div
        style={{
          textAlign: "center",
          fontSize: "15px",
          color: isComplete ? "#2196f3" : isCharging ? "#00BFA6" : "#666",
          fontWeight: "600",
          padding: "10px 20px",
          background: isComplete
            ? "rgba(33, 150, 243, 0.1)"
            : isCharging
            ? "rgba(0, 191, 166, 0.1)"
            : "rgba(0, 0, 0, 0.05)",
          borderRadius: "20px",
        }}
      >
        {isComplete
          ? "‚úÖ Ho√†n t·∫•t s·∫°c"
          : isCharging
          ? "‚ö° ƒêang s·∫°c..."
          : "Dung l∆∞·ª£ng pin (∆∞·ªõc t√≠nh)"}
      </div>

      <style>{`
        @keyframes pulse {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.1); opacity: 0.8; }
        }
      `}</style>
    </div>
  );
});

// Info Card Component
const InfoCard = memo(function InfoCard({
  icon,
  label,
  value,
  color = "#00BFA6",
  unit = "",
}) {
  return (
    <div
      style={{
        background: "white",
        padding: "20px",
        borderRadius: "12px",
        boxShadow: "0 2px 12px rgba(0,0,0,0.06)",
        textAlign: "center",
        border: `2px solid ${color}15`,
        transition: "transform 0.2s ease, box-shadow 0.2s ease",
      }}
      onMouseEnter={(e) => {
        e.currentTarget.style.transform = "translateY(-3px)";
        e.currentTarget.style.boxShadow = "0 4px 20px rgba(0,0,0,0.12)";
      }}
      onMouseLeave={(e) => {
        e.currentTarget.style.transform = "translateY(0)";
        e.currentTarget.style.boxShadow = "0 2px 12px rgba(0,0,0,0.06)";
      }}
    >
      <div style={{ fontSize: "32px", marginBottom: "8px" }}>{icon}</div>
      <div
        style={{
          fontSize: "13px",
          color: "#666",
          marginBottom: "8px",
          fontWeight: "500",
        }}
      >
        {label}
      </div>
      <div
        style={{
          fontSize: "24px",
          fontWeight: "700",
          color: color,
        }}
      >
        {value}
        {unit && (
          <span
            style={{ fontSize: "16px", fontWeight: "500", marginLeft: "4px" }}
          >
            {unit}
          </span>
        )}
      </div>
    </div>
  );
});

export default function ChargingSession() {
  const navigate = useNavigate();
  const location = useLocation();
  const params = useParams();

  const [currentSession, setCurrentSession] = useState(null);
  const [loading, setLoading] = useState(false);
  const [stopping, setStopping] = useState(false);
  const [autoRedirected, setAutoRedirected] = useState(false);
  const [currentPower, setCurrentPower] = useState(0); // ‚úÖ Track maxPowerKW separately
  const [lastEnergySync, setLastEnergySync] = useState(null); // ‚úÖ Track last Backend energy sync
  const [batteryCapacity, setBatteryCapacity] = useState(getBatteryCapacity()); // ‚úÖ Real battery capacity from vehicle model

  // QR / booking state (merged behavior)
  const qrFromState = location?.state?.qrBlobUrl;
  const stateBooking = location?.state?.booking;
  const bookingIdFromParams = params?.bookingId;

  const [qrUrl, setQrUrl] = useState(qrFromState || null);
  const [booking, setBooking] = useState(stateBooking || null);
  const [bookingLoading, setBookingLoading] = useState(false);

  // Battery capacity constant (used by BatteryProgressCircle)
  const DEFAULT_BATTERY_CAPACITY = getBatteryCapacity(); // kWh

  // üé® Status color mapping for cleaner code
  const statusColors = {
    IN_PROGRESS: "#4caf50",
    COMPLETED: "#2196f3",
    FAILED: "#f44336",
    PENDING: "#ff9800",
  };

  // Helper to build sessionStorage key
  const qrStorageKey = (id) => (id ? `qr_booking_${id}` : null);

  // Update battery capacity from sessionStorage on mount
  useEffect(() => {
    const capacity = getBatteryCapacity();
    setBatteryCapacity(capacity);
  }, []);

  // üîã Simulation state persistence helpers
  const getSimulationKey = (sessionId) =>
    sessionId ? `chargingSession_simulation_${sessionId}` : null;

  const saveSimState = useCallback((session) => {
    if (!session || !session.sessionId) return;
    try {
      const key = getSimulationKey(session.sessionId);
      if (!key) return;
      localStorage.setItem(
        key,
        JSON.stringify({
          sessionId: session.sessionId,
          virtualSoc: session.virtualSoc,
          energyKWh: session.energyKWh,
          durationMinutes: session.durationMinutes,
          lastUpdated: Date.now(),
          status: session.status,
        })
      );
    } catch (err) {
      console.debug("Failed to save simulation state:", err);
    }
  }, []);

  const clearSimState = useCallback(
    (sessionId) => {
      if (!sessionId) return;
      try {
        const key = getSimulationKey(sessionId);
        if (key) localStorage.removeItem(key);

        // ‚úÖ Also clear maxPowerKW from sessionStorage
        if (currentSession?.bookingId) {
          const powerKey = `booking_${currentSession.bookingId}_maxPowerKW`;
          sessionStorage.removeItem(powerKey);
          console.log(
            `üóëÔ∏è Cleared maxPowerKW for booking #${currentSession.bookingId}`
          );
        }
      } catch (err) {
        console.debug("Failed to clear simulation state:", err);
      }
    },
    [currentSession]
  );

  // If navigation state didn't include qrBlobUrl, try to restore from sessionStorage (data URL)
  useEffect(() => {
    if (qrUrl) return; // already have one

    const attemptRestore = () => {
      // try bookingIdFromParams, booking object, then currentSession bookingId
      const idCandidates = [
        bookingIdFromParams,
        booking?.bookingId ?? booking?.id,
        currentSession?.bookingId,
      ];

      for (const id of idCandidates) {
        if (!id) continue;
        try {
          const key = qrStorageKey(id);
          const stored = key ? sessionStorage.getItem(key) : null;
          if (stored) {
            // stored is a data URL (base64) created at confirm time
            // use it as the qrUrl so <img src=qrUrl /> can render it
            setQrUrl(stored);
            return;
          }
        } catch {
          // ignore storage errors
        }
      }

      // fallback: if there's exactly one qr_booking_ key in sessionStorage, use it
      try {
        const keys = Object.keys(sessionStorage).filter(
          (k) => k && k.startsWith("qr_booking_")
        );
        if (keys.length === 1) {
          const s = sessionStorage.getItem(keys[0]);
          if (s) setQrUrl(s);
        }
      } catch {
        // ignore
      }
    };

    attemptRestore();
  }, [booking, bookingIdFromParams, qrUrl, currentSession]);

  useEffect(() => {
    if (!isAuthenticated()) {
      toast.warning(
        "B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p. Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem phi√™n s·∫°c!",
        {
          position: "top-center",
          autoClose: 3000,
        }
      );
      navigate(paths.login);
      return;
    }

    fetchCurrentSession();
  }, [navigate]);

  // ‚úÖ Battery capacity now loaded from sessionStorage on mount
  useEffect(() => {
    // Battery capacity is now loaded from sessionStorage via getBatteryCapacity()
  }, [currentSession?.vehicle?.model?.modelId]);

  const fetchCurrentSession = async () => {
    try {
      setLoading(true);
      const response = await stationAPI.getCurrentChargingSession();
      if (!response || response.success === false) {
        console.log("‚ùå No current session");
        setCurrentSession(null);
        setCurrentPower(0);
        return;
      }
      const session = response.data ?? response;
      console.log("‚úÖ Current session data:", session);

      // ‚úÖ S·ª≠ d·ª•ng helper ƒë·ªÉ extract power
      const power = extractPowerKW(session, session.bookingId);

      // ‚úÖ Extract pointNumber from chargingPoint (v√¨ ViewCharSessionResponse kh√¥ng c√≥ field n√†y)
      const pointNumber =
        session.pointNumber ??
        session.chargingPoint?.pointNumber ??
        session.chargingPoint?.point_number ??
        null;

      setCurrentPower(power);
      setCurrentSession({
        ...session,
        pointNumber: pointNumber, // ‚úÖ Th√™m pointNumber v√†o session
      });
    } catch (error) {
      console.error("L·ªói khi l·∫•y phi√™n s·∫°c hi·ªán t·∫°i:", error);
      toast.error("Kh√¥ng th·ªÉ l·∫•y th√¥ng tin phi√™n s·∫°c", {
        position: "top-center",
      });
    } finally {
      setLoading(false);
    }
  };

  // ‚ö° Polling maxPowerKW: Update charging power realtime when database changes
  useEffect(() => {
    if (!currentSession || currentSession.status !== "IN_PROGRESS") return;

    const pollPowerInterval = setInterval(async () => {
      try {
        const response = await stationAPI.getCurrentChargingSession();
        const updatedSession = response.data ?? response;

        const newPower = updatedSession.chargingPoint?.maxPowerKW;

        if (newPower && newPower !== currentPower) {
          console.log(`‚ö° Power updated: ${currentPower} kW ‚Üí ${newPower} kW`);
          setCurrentPower(newPower);
        }
      } catch (err) {
        console.debug("Polling power error:", err);
      }
    }, POWER_POLLING_INTERVAL);

    return () => clearInterval(pollPowerInterval);
  }, [currentSession, currentPower]); // ‚úÖ Include full currentSession

  // ‚ö° CRITICAL: Poll Backend energy every 30s to sync with actual calculation
  // Backend calculates: energyKWh = round2((duration √ó power √ó efficiency) / capacity √ó 100)
  // This prevents Frontend simulation from "jumping ahead" due to timing issues
  useEffect(() => {
    if (!currentSession || currentSession.status !== "IN_PROGRESS") return;

    const pollEnergyInterval = setInterval(async () => {
      try {
        console.log(
          `üîÑ Syncing energy from Backend (every ${
            ENERGY_POLLING_INTERVAL / 1000
          }s)...`
        );
        const response = await stationAPI.getCurrentChargingSession();
        const backendSession = response.data ?? response;

        if (backendSession && backendSession.status === "IN_PROGRESS") {
          // Calculate Backend energy using exact same formula
          const startTime = new Date(backendSession.startTime);
          const now = new Date();
          const durationMs = now - startTime;
          const durationMinutes = durationMs / (1000 * 60);
          const hours = durationMinutes / 60;

          const power = currentPower || 11.0;
          const capacity = batteryCapacity; // ‚úÖ Use real battery capacity from API
          const efficiency = CHARGING_EFFICIENCY;
          const initialSoc = backendSession.initialSoc ?? 20;

          // Backend formula: energyKWh = round2((deltaSoc / 100.0) * batteryCapacity)
          // where deltaSoc comes from: (hours √ó power √ó efficiency / capacity) √ó 100
          const estimatedEnergyDelivered = hours * power * efficiency;
          const estimatedSocIncrease =
            (estimatedEnergyDelivered / capacity) * 100.0;
          let rawFinalSOC = initialSoc + estimatedSocIncrease;

          // Minimum 1% increase if charging
          if (durationMinutes > 0 && Math.floor(rawFinalSOC) === initialSoc) {
            rawFinalSOC = initialSoc + 1;
          }

          let finalSOC = Math.round(rawFinalSOC);
          finalSOC = Math.min(100, Math.max(initialSoc, finalSOC));

          const deltaSoc = finalSOC - initialSoc;
          const backendEnergy = round2((deltaSoc / 100.0) * capacity);

          console.log(
            `üìä Backend energy sync: ${backendEnergy.toFixed(
              2
            )} kWh (SOC: ${initialSoc}% ‚Üí ${finalSOC}%, duration: ${durationMinutes.toFixed(
              1
            )}min, power: ${power}kW)`
          );

          // Update session with Backend-calculated values
          setCurrentSession((prev) => {
            if (!prev || prev.status !== "IN_PROGRESS") return prev;

            // ‚úÖ Auto-stop if Backend calculated SOC >= 100
            if (finalSOC >= 100) {
              console.log(
                "üîã Backend calculated SOC >= 100% - auto-stopping session"
              );

              // Stop session with 100%
              stationAPI
                .stopChargingSession(prev.sessionId, 100)
                .then((response) => {
                  console.log(
                    `‚úÖ Session #${prev.sessionId} auto-stopped at 100% SOC from Backend`
                  );
                  const sessionResult = response.data ?? response;
                  setCurrentSession((current) =>
                    current
                      ? syncSessionFromBackend(sessionResult, current)
                      : current
                  );
                })
                .catch((err) => {
                  console.error("‚ùå Failed to auto-stop session at 100%:", err);
                });

              return prev; // Don't update state, let polling detect COMPLETED
            }

            return {
              ...prev,
              energyKWh: backendEnergy,
              virtualSoc: finalSOC,
              durationMinutes: durationMinutes,
            };
          });

          setLastEnergySync(new Date());
        }
      } catch (err) {
        console.debug("Energy polling error:", err);
      }
    }, ENERGY_POLLING_INTERVAL);

    // Run immediately on mount, then every 30s
    (async () => {
      try {
        const response = await stationAPI.getCurrentChargingSession();
        const backendSession = response.data ?? response;
        if (backendSession && backendSession.status === "IN_PROGRESS") {
          const startTime = new Date(backendSession.startTime);
          const now = new Date();
          const durationMinutes = (now - startTime) / (1000 * 60);
          const hours = durationMinutes / 60;
          const power = currentPower || 11.0;
          const capacity = batteryCapacity; // ‚úÖ Use real battery capacity from API
          const initialSoc = backendSession.initialSoc ?? 20;
          const estimatedEnergyDelivered = hours * power * CHARGING_EFFICIENCY;
          const estimatedSocIncrease =
            (estimatedEnergyDelivered / capacity) * 100.0;
          let rawFinalSOC = initialSoc + estimatedSocIncrease;
          if (durationMinutes > 0 && Math.floor(rawFinalSOC) === initialSoc) {
            rawFinalSOC = initialSoc + 1;
          }
          let finalSOC = Math.round(rawFinalSOC);
          finalSOC = Math.min(100, Math.max(initialSoc, finalSOC));
          const deltaSoc = finalSOC - initialSoc;
          const backendEnergy = round2((deltaSoc / 100.0) * capacity);
          console.log(
            `üìä Initial Backend energy sync: ${backendEnergy.toFixed(2)} kWh`
          );
          setCurrentSession((prev) => {
            if (!prev || prev.status !== "IN_PROGRESS") return prev;

            // ‚úÖ Auto-stop if Backend calculated SOC >= 100
            if (finalSOC >= 100) {
              console.log(
                "üîã Initial Backend sync: SOC >= 100% - auto-stopping session"
              );

              stationAPI
                .stopChargingSession(prev.sessionId, 100)
                .then((response) => {
                  console.log(
                    `‚úÖ Session #${prev.sessionId} auto-stopped at 100% SOC from initial Backend sync`
                  );
                  const sessionResult = response.data ?? response;
                  setCurrentSession((current) =>
                    current
                      ? syncSessionFromBackend(sessionResult, current)
                      : current
                  );
                })
                .catch((err) => {
                  console.error("‚ùå Failed to auto-stop session at 100%:", err);
                });

              return prev;
            }

            return {
              ...prev,
              energyKWh: backendEnergy,
              virtualSoc: finalSOC,
              durationMinutes,
            };
          });
          setLastEnergySync(new Date());
        }
      } catch (err) {
        console.debug("Initial energy sync error:", err);
      }
    })();

    return () => clearInterval(pollEnergyInterval);
  }, [currentSession, currentPower, batteryCapacity]); // ‚úÖ Include batteryCapacity

  // ‚ö° Polling: check current session periodically (mainly for status changes)
  // During IN_PROGRESS, frontend handles all calculations via virtualSoc
  // Poll every 2s to quickly detect when Staff stops the session
  useEffect(() => {
    let intervalId = null;

    // small wrapper to call API and update state
    const poll = async () => {
      try {
        // ‚úÖ Use /api/driver/sessions instead of /current
        // This API returns ALL sessions (including COMPLETED), no error when stopped
        const response = await getMySessions();
        if (!response || response.success === false) {
          setCurrentSession(null);
          return;
        }

        const sessions = response.data ?? response;
        if (!Array.isArray(sessions) || sessions.length === 0) {
          setCurrentSession(null);
          return;
        }

        // First, try to find IN_PROGRESS session
        const inProgressSession = sessions.find((s) => {
          const status = String(s.status || "").toUpperCase();
          return status === "IN_PROGRESS";
        });

        // If found IN_PROGRESS, use it
        if (inProgressSession) {
          console.log(
            `üìä Found IN_PROGRESS session #${inProgressSession.sessionId}`
          );

          // ‚úÖ Update currentPower from sessionStorage when session starts
          const bookingId = inProgressSession.bookingId;
          if (bookingId) {
            try {
              const key = `booking_${bookingId}_maxPowerKW`;
              const storedPower = sessionStorage.getItem(key);
              if (storedPower) {
                const power = JSON.parse(storedPower);
                setCurrentPower(power);
                console.log(
                  `‚ö° Auto-loaded maxPowerKW=${power} kW from sessionStorage for booking #${bookingId}`
                );
              }
            } catch (e) {
              console.debug("Failed to auto-load maxPowerKW:", e);
            }
          }

          setCurrentSession((prev) => {
            if (!prev) return inProgressSession;

            // If session changed, update
            if (prev.sessionId !== inProgressSession.sessionId)
              return inProgressSession;

            // If status changed (should not happen for IN_PROGRESS to IN_PROGRESS)
            if (prev.status !== inProgressSession.status) {
              console.log(
                `üîÑ Session status changed: ${prev.status} ‚Üí ${inProgressSession.status}`
              );
              return {
                ...inProgressSession,
                virtualSoc: prev.virtualSoc,
              };
            }

            // Keep frontend simulation for IN_PROGRESS
            return prev;
          });
          return;
        }

        // No IN_PROGRESS session found - check if we HAD one that just completed
        setCurrentSession((prev) => {
          if (!prev || !prev.sessionId) {
            // No previous session, and no IN_PROGRESS ‚Üí nothing to show
            return null;
          }

          // We had a session - check if it's now COMPLETED
          const prevSessionId = prev.sessionId;
          const completedSession = sessions.find(
            (s) => s.sessionId === prevSessionId
          );

          if (completedSession) {
            const status = String(completedSession.status || "").toUpperCase();
            console.log(
              `üìä Previous session #${prevSessionId} is now: ${status}`
            );

            if (status === "COMPLETED" || status === "FINISHED") {
              // ‚úÖ Session completed - ƒë·ªìng b·ªô ƒë·∫ßy ƒë·ªß d·ªØ li·ªáu t·ª´ Backend
              console.log(
                `üìä Session #${prevSessionId} COMPLETED - syncing from backend:`,
                {
                  finalSoc: completedSession.finalSoc,
                  energyKWh: completedSession.energyKWh,
                  durationMinutes: completedSession.durationMinutes,
                  endTime: completedSession.endTime,
                  cost: completedSession.cost,
                }
              );

              // ‚úÖ FIX: T√≠nh pricePerKWh t·ª´ cost/energyKWh (v√¨ ViewCharSessionResponse kh√¥ng c√≥ field n√†y)
              // S·ª≠ d·ª•ng round2 ƒë·ªÉ ƒë·ªìng nh·∫•t v·ªõi Backend (Math.round(v * 100) / 100)
              const pricePerKWh =
                completedSession.energyKWh > 0
                  ? Math.round(
                      (completedSession.cost / completedSession.energyKWh) * 100
                    ) / 100
                  : 0;

              return {
                ...completedSession,
                // ‚úÖ ƒê·ªìng b·ªô virtualSoc v·ªõi finalSoc t·ª´ Backend ƒë·ªÉ UI hi·ªÉn th·ªã ƒë√∫ng
                virtualSoc: completedSession.finalSoc,
                // ‚úÖ Th√™m pricePerKWh ƒë·ªÉ hi·ªÉn th·ªã trong Payment
                pricePerKWh: pricePerKWh,
                // ‚úÖ Gi·ªØ pointNumber t·ª´ prev (v√¨ ViewCharSessionResponse kh√¥ng c√≥ field n√†y)
                pointNumber: prev.pointNumber || completedSession.pointNumber,
              };
            }
          }

          // Session not found or status unclear - keep previous
          return prev;
        });
      } catch (err) {
        console.error("Polling getMySessions error:", err);
        // Don't clear session on error, keep previous state
      }
    };

    // run immediately then set interval
    poll();
    // ‚ö° Poll every 2 seconds for faster detection when Staff stops session
    intervalId = setInterval(poll, POLLING_INTERVAL);

    return () => {
      if (intervalId) clearInterval(intervalId);
    };
  }, []); // ‚úÖ Empty deps - ch·ªâ ch·∫°y m·ªôt l·∫ßn khi mount

  // üîã Virtual SOC simulation - UI SMOOTHING ONLY
  // Backend energy polling (every 30s) provides accurate values
  // This just smooths the UI between Backend syncs for better UX
  useEffect(() => {
    if (!currentSession || currentSession.status !== "IN_PROGRESS") {
      // Clean up simulation state if session is not in progress
      if (currentSession?.sessionId) {
        clearSimState(currentSession.sessionId);
      }
      return;
    }

    // Get parameters from session or use defaults
    const capacity = batteryCapacity; // ‚úÖ Use real battery capacity from API
    const efficiency = 0.9; // ‚úÖ Match backend exactly (ChargingSessionTxHandler)
    const initialSoc = currentSession.initialSoc ?? 20;

    // ‚úÖ Initialize virtualSoc if not set
    if (!currentSession.virtualSoc) {
      setCurrentSession((prev) =>
        prev ? { ...prev, virtualSoc: initialSoc } : prev
      );
    }

    const virtualChargeInterval = setInterval(() => {
      setCurrentSession((prev) => {
        if (!prev || prev.status !== "IN_PROGRESS") return prev;

        // ‚úÖ Use current energyKWh from Backend sync (updated every 30s)
        // Only update durationMinutes for UI display
        const startTime = new Date(prev.startTime);
        const now = new Date();
        const durationMs = now - startTime;
        const durationMinutes = durationMs / (1000 * 60);

        // Calculate current SOC for smooth UI (between Backend syncs)
        const { finalSOC } = calculateChargingMetrics({
          startTime: prev.startTime,
          initialSoc: initialSoc,
          powerKW: currentPower || 11.0,
          capacity: capacity,
          efficiency: efficiency,
        });

        // ‚úÖ Log every 5 minutes (less spam, Backend sync logs every 30s)
        if (Math.floor(durationMinutes) % 5 === 0 && durationMinutes > 0) {
          console.log(
            `üìä UI update: duration=${durationMinutes.toFixed(1)}min, energy=${(
              prev.energyKWh ?? 0
            ).toFixed(2)}kWh (from Backend), SOC=${finalSOC}%`
          );
        }

        // Auto-complete when reaching 100%
        if (finalSOC >= 100) {
          console.log("üîã Battery reached 100% - auto-stopping session");

          // ‚úÖ G·ª≠i 100% v√¨ ƒë√£ ƒë·∫°t ƒë·∫ßy pin
          stationAPI
            .stopChargingSession(prev.sessionId, 100)
            .then((response) => {
              console.log(
                `‚úÖ Session #${prev.sessionId} auto-stopped - Backend calculated final values`
              );
              const sessionResult = response.data ?? response;
              // ‚úÖ S·ª≠ d·ª•ng helper function ƒë·ªÉ sync data
              setCurrentSession((current) =>
                current
                  ? syncSessionFromBackend(sessionResult, current)
                  : current
              );
              // Polling s·∫Ω detect COMPLETED v√† update UI v·ªõi d·ªØ li·ªáu ch√≠nh x√°c t·ª´ Backend
            })
            .catch((err) => {
              console.error("‚ùå Failed to stop session at 100%:", err);
            });

          clearInterval(virtualChargeInterval);
          clearSimState(prev.sessionId);
          // Polling s·∫Ω detect COMPLETED status t·ª´ backend v√† auto-redirect
          return prev;
        }

        // Update UI state (energy comes from Backend polling every 30s)
        const updatedSession = {
          ...prev,
          virtualSoc: finalSOC,
          durationMinutes: durationMinutes,
          // energyKWh: Keep value from Backend sync (updated every 30s via energy polling)
        };

        saveSimState(updatedSession);

        // ‚úÖ L∆∞u virtualSoc v√†o sessionStorage ƒë·ªÉ Staff c√≥ th·ªÉ ƒë·ªçc khi d·ª´ng phi√™n s·∫°c
        // Key format: session_${sessionId}_live_soc
        try {
          const liveDataKey = `session_${prev.sessionId}_live_soc`;
          const liveData = {
            sessionId: prev.sessionId,
            virtualSoc: Math.round(finalSOC), // L∆∞u s·ªë nguy√™n
            energyKWh: prev.energyKWh ?? 0, // ‚úÖ Use Backend-synced value
            durationMinutes: durationMinutes,
            timestamp: Date.now(),
            lastEnergySync: lastEnergySync?.toISOString() ?? null,
          };
          sessionStorage.setItem(liveDataKey, JSON.stringify(liveData));
        } catch (err) {
          console.debug("Failed to save live SOC to sessionStorage:", err);
        }

        return updatedSession;
      });
    }, 1000); // Update every 1 second (realtime mode)

    return () => {
      clearInterval(virtualChargeInterval);
    };
  }, [
    currentSession,
    currentPower,
    clearSimState,
    saveSimState,
    lastEnergySync,
    batteryCapacity,
  ]); // ‚úÖ ƒê·∫ßy ƒë·ªß dependencies

  // üß≠ Auto redirect to payment page when charging completes
  // Triggers when status changes to COMPLETED or STOPPED (by Staff)
  useEffect(() => {
    if (!currentSession) return;

    console.log(
      `üîç Auto-redirect check: status="${currentSession.status}", autoRedirected=${autoRedirected}`
    );

    // Normalize status to uppercase for comparison (backend may return different cases)
    const normalizedStatus = String(currentSession.status || "").toUpperCase();

    // Khi tr·∫°ng th√°i chuy·ªÉn sang COMPLETED ho·∫∑c STOPPED (Staff d·ª´ng) v√† ch∆∞a redirect
    const isSessionEnded =
      normalizedStatus === "COMPLETED" ||
      normalizedStatus === "STOPPED" ||
      normalizedStatus === "FINISHED";

    if (isSessionEnded && !autoRedirected) {
      console.log(
        `‚úÖ Session ended with status: ${currentSession.status} - Redirecting to payment...`
      );
      setAutoRedirected(true);

      const message =
        normalizedStatus === "STOPPED"
          ? "‚èπ Phi√™n s·∫°c ƒë√£ b·ªã d·ª´ng. ƒêang chuy·ªÉn sang trang thanh to√°n..."
          : "‚ö° Phi√™n s·∫°c ƒë√£ ho√†n t·∫•t. ƒêang chuy·ªÉn sang trang thanh to√°n...";

      toast.info(message, {
        position: "top-center",
        autoClose: 2000,
      });

      // Clear simulation state
      clearSimState(currentSession.sessionId);

      // ‚úÖ X√≥a live SOC data kh·ªèi sessionStorage khi phi√™n s·∫°c k·∫øt th√∫c
      try {
        const liveDataKey = `session_${currentSession.sessionId}_live_soc`;
        sessionStorage.removeItem(liveDataKey);
      } catch (err) {
        console.debug("Failed to remove live SOC from sessionStorage:", err);
      }

      // Chuy·ªÉn sang trang thanh to√°n sau 2s
      setTimeout(() => {
        navigate(paths.payment, { state: { sessionResult: currentSession } });
      }, 2000);
    }
  }, [currentSession, autoRedirected, navigate, clearSimState]);

  // ‚è∞ Auto-stop session when booking time expires
  useEffect(() => {
    if (!currentSession || currentSession.status !== "IN_PROGRESS") return;
    if (!currentSession.windowEnd) return;

    const checkExpiry = setInterval(() => {
      const now = new Date();
      const endTime = new Date(currentSession.windowEnd);

      if (now >= endTime) {
        console.log("‚è∞ Booking time expired - auto-stopping session");

        // ‚úÖ G·ª≠i virtualSoc hi·ªán t·∫°i khi h·∫øt th·ªùi gian
        const currentFinalSoc = Math.round(
          currentSession.virtualSoc || currentSession.initialSoc || 20
        );
        stationAPI
          .stopChargingSession(currentSession.sessionId, currentFinalSoc)
          .then((response) => {
            console.log(
              `‚úÖ Session #${currentSession.sessionId} auto-stopped at time expiry - finalSoc=${currentFinalSoc}%`
            );
            const sessionResult = response.data ?? response;
            // ‚úÖ S·ª≠ d·ª•ng helper function
            setCurrentSession((current) =>
              current ? syncSessionFromBackend(sessionResult, current) : current
            );
            // Polling s·∫Ω detect COMPLETED v√† c·∫≠p nh·∫≠t UI v·ªõi d·ªØ li·ªáu ch√≠nh x√°c t·ª´ Backend
          })
          .catch((err) => {
            console.error("‚ùå Failed to stop session on time expiry:", err);
          });

        clearInterval(checkExpiry);
      }
    }, 5000); // Check every 5 seconds

    return () => clearInterval(checkExpiry);
  }, [currentSession]);

  const handleStopSession = async () => {
    if (!currentSession?.sessionId) {
      toast.error("Kh√¥ng c√≥ sessionId ƒë·ªÉ d·ª´ng", { position: "top-center" });
      return;
    }
    if (!window.confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën d·ª´ng phi√™n s·∫°c n√†y kh√¥ng?"))
      return;

    try {
      setStopping(true);

      // Stop virtual animation immediately by changing status
      // This triggers useEffect cleanup and clears the interval
      setCurrentSession((prev) =>
        prev ? { ...prev, status: "STOPPING" } : prev
      );

      // ‚úÖ G·ª≠i virtualSoc hi·ªán t·∫°i ƒë·ªÉ Backend t√≠nh ch√≠nh x√°c v·ªõi battery capacity th·ª±c
      // Frontend ƒë√£ t√≠nh virtualSoc v·ªõi battery capacity t·ª´ sessionStorage
      const finalSocToSend = Math.round(
        currentSession.virtualSoc || currentSession.initialSoc || 20
      );

      console.log(
        `üõë Driver stopping session #${currentSession.sessionId} - Sending finalSoc=${finalSocToSend}% to Backend`
      );

      const response = await stationAPI.stopChargingSession(
        currentSession.sessionId,
        finalSocToSend
      );
      if (!response || response.success === false) {
        // Revert status if stop failed
        setCurrentSession((prev) =>
          prev ? { ...prev, status: "IN_PROGRESS" } : prev
        );
        toast.error(response?.message || "D·ª´ng phi√™n s·∫°c th·∫•t b·∫°i", {
          position: "top-center",
        });
        return;
      }

      const sessionResult = response.data ?? response;

      // ‚úÖ C·∫≠p nh·∫≠t UI v·ªõi d·ªØ li·ªáu ch√≠nh x√°c t·ª´ Backend (s·ª≠ d·ª•ng helper)
      console.log(
        `‚úÖ Backend response: finalSoc=${sessionResult.finalSoc}%, ` +
          `energyKWh=${sessionResult.energyKWh}, ` +
          `duration=${sessionResult.durationMinutes}min, ` +
          `cost=${sessionResult.cost}`
      );

      setCurrentSession((prev) =>
        prev ? syncSessionFromBackend(sessionResult, prev) : prev
      );

      toast.success("D·ª´ng phi√™n s·∫°c th√†nh c√¥ng!", { position: "top-center" });

      // Clear simulation state from localStorage
      clearSimState(currentSession.sessionId);

      // cleanup persisted QR for this booking (if any)
      try {
        const key = qrStorageKey(
          booking?.bookingId ??
            bookingIdFromParams ??
            sessionResult?.bookingId ??
            currentSession?.bookingId
        );
        if (key) sessionStorage.removeItem(key);
      } catch {
        // ignore
      }

      // Navigate to payment after a short delay to show final state
      setTimeout(() => {
        // ‚úÖ S·ª≠ d·ª•ng callback ƒë·ªÉ ƒë·∫£m b·∫£o l·∫•y state m·ªõi nh·∫•t
        setCurrentSession((latestSession) => {
          if (latestSession) {
            // ‚úÖ Ki·ªÉm tra d·ªØ li·ªáu ƒë√£ ƒë·∫ßy ƒë·ªß tr∆∞·ªõc khi navigate
            const hasRequiredData =
              latestSession.finalSoc != null &&
              latestSession.energyKWh != null &&
              latestSession.cost != null;

            if (hasRequiredData) {
              console.log("‚úÖ Navigating to payment with complete data:", {
                finalSoc: latestSession.finalSoc,
                energyKWh: latestSession.energyKWh,
                cost: latestSession.cost,
                pointNumber: latestSession.pointNumber,
                pricePerKWh: latestSession.pricePerKWh,
              });
              navigate(paths.payment, {
                state: {
                  sessionResult: latestSession,
                },
              });
            } else {
              console.warn("‚ö†Ô∏è Session data incomplete, waiting for sync...");
              // N·∫øu data ch∆∞a ƒë·∫ßy ƒë·ªß, polling s·∫Ω t·ª± ƒë·ªông redirect sau khi detect COMPLETED
            }
          }
          return latestSession;
        });
      }, 1500);
    } catch (err) {
      console.error("L·ªói khi d·ª´ng phi√™n s·∫°c:", err);
      // Revert status if error occurred
      setCurrentSession((prev) =>
        prev ? { ...prev, status: "IN_PROGRESS" } : prev
      );
      toast.error("D·ª´ng phi√™n s·∫°c th·∫•t b·∫°i", { position: "top-center" });
    } finally {
      setStopping(false);
    }
  };

  // Load booking by param if needed
  useEffect(() => {
    if (!booking && bookingIdFromParams) {
      (async () => {
        try {
          setBookingLoading(true);
          const res = await stationAPI.getBookingById(bookingIdFromParams);
          if (!res || res.success === false) {
            toast.error(res?.message || "Kh√¥ng th·ªÉ l·∫•y booking", {
              position: "top-center",
            });
            return;
          }
          setBooking(res.data ?? res);
        } catch (err) {
          console.error("Error fetching booking:", err);
        } finally {
          setBookingLoading(false);
        }
      })();
    }
  }, [booking, bookingIdFromParams]);

  // If a current session becomes IN_PROGRESS, remove any persisted QR for that booking
  useEffect(() => {
    if (!currentSession) return;
    if (currentSession.status === "IN_PROGRESS") {
      try {
        const id =
          booking?.bookingId ?? bookingIdFromParams ?? currentSession.bookingId;
        const key = qrStorageKey(id);
        if (key) sessionStorage.removeItem(key);
        // hide qrUrl if it was showing
        setQrUrl(null);
      } catch {
        // ignore
      }
    }
  }, [currentSession, booking, bookingIdFromParams]);

  // Cleanup blob URL on unmount
  useEffect(() => {
    return () => {
      if (qrUrl && typeof qrUrl === "string" && qrUrl.startsWith("blob:")) {
        try {
          URL.revokeObjectURL(qrUrl);
        } catch {
          // ignore
        }
      }
    };
  }, [qrUrl]);

  const handleDownload = () => {
    if (!qrUrl) return;
    const a = document.createElement("a");
    a.href = qrUrl;
    a.download = `booking-${
      booking?.bookingId ?? bookingIdFromParams ?? "qr"
    }.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  };

  // Manual restore helper (visible when automatic restore fails)
  const restoreAnyQr = () => {
    try {
      const keys = Object.keys(sessionStorage).filter(
        (k) => k && k.startsWith("qr_booking_")
      );
      if (!keys || keys.length === 0) {
        toast.info("Kh√¥ng t√¨m th·∫•y QR l∆∞u tr·ªØ n√†o trong sessionStorage", {
          position: "top-center",
        });
        return;
      }
      // prefer match by bookingId if available
      let keyToUse = null;
      const idCandidates = [
        bookingIdFromParams,
        booking?.bookingId ?? booking?.id,
        currentSession?.bookingId,
      ];
      for (const id of idCandidates) {
        if (!id) continue;
        const candidateKey = `qr_booking_${id}`;
        if (keys.includes(candidateKey)) {
          keyToUse = candidateKey;
          break;
        }
      }
      if (!keyToUse) {
        // fallback to first key
        keyToUse = keys[0];
      }
      const val = sessionStorage.getItem(keyToUse);
      if (val) {
        setQrUrl(val);
        toast.success("Kh√¥i ph·ª•c QR th√†nh c√¥ng", { position: "top-center" });
      } else {
        toast.error("Kh√¥ng th·ªÉ ƒë·ªçc QR t·ª´ sessionStorage", {
          position: "top-center",
        });
      }
    } catch (e) {
      console.warn("restoreAnyQr error", e);
      toast.error("L·ªói khi kh√¥i ph·ª•c QR", { position: "top-center" });
    }
  };

  return (
    <div
      className="charging-session-container"
      style={{ padding: "20px", maxWidth: "1200px", margin: "0 auto" }}
    >
      <h1 style={{ color: "#00BFA6", marginBottom: "30px" }}>
        Phi√™n s·∫°c hi·ªán t·∫°i
      </h1>

      {loading ? (
        <p>ƒêang t·∫£i th√¥ng tin phi√™n s·∫°c...</p>
      ) : qrUrl &&
        (!currentSession || currentSession.status !== "IN_PROGRESS") ? (
        <div
          style={{
            background: "white",
            padding: "20px",
            borderRadius: "12px",
            boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
            textAlign: "center",
          }}
        >
          <h2 style={{ color: "#333", marginBottom: "15px" }}>M√£ QR ƒë·∫∑t ch·ªó</h2>

          {bookingLoading ? (
            <p>ƒêang t·∫£i th√¥ng tin booking...</p>
          ) : (
            <>
              {qrUrl ? (
                <div style={{ textAlign: "center", marginTop: 12 }}>
                  <img
                    src={qrUrl}
                    alt="QR Code"
                    style={{ maxWidth: "320px", width: "100%", height: "auto" }}
                  />
                  <div style={{ marginTop: 12 }}>
                    <button
                      onClick={handleDownload}
                      style={{
                        padding: "10px 18px",
                        borderRadius: 8,
                        background: "#00BFA6",
                        color: "white",
                        border: "none",
                      }}
                    >
                      T·∫£i m√£ QR
                    </button>
                  </div>
                </div>
              ) : (
                <div style={{ marginTop: 12 }}>
                  <p>QR ch∆∞a c√≥. Vui l√≤ng x√°c nh·∫≠n booking tr∆∞·ªõc.</p>
                  <div style={{ marginTop: 8 }}>
                    <button
                      onClick={restoreAnyQr}
                      style={{
                        padding: "8px 12px",
                        borderRadius: 8,
                        background: "#1976d2",
                        color: "white",
                        border: "none",
                      }}
                    >
                      Kh√¥i ph·ª•c QR
                    </button>
                  </div>
                </div>
              )}
            </>
          )}
        </div>
      ) : currentSession ? (
        <div
          style={{
            background: "white",
            padding: "20px",
            borderRadius: "12px",
            boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
          }}
        >
          <h2 style={{ color: "#333", marginBottom: "15px" }}>
            ‚ö° Th√¥ng tin phi√™n s·∫°c
          </h2>

          <div style={{ marginBottom: "20px" }}>
            <p style={{ marginBottom: "10px" }}>
              <strong>Booking ID:</strong> {currentSession.bookingId ?? "-"}
            </p>
            <p style={{ marginBottom: "10px" }}>
              <strong>Tr·∫°ng th√°i:</strong>{" "}
              <span
                style={{
                  padding: "4px 12px",
                  borderRadius: "20px",
                  background: statusColors[currentSession.status] || "#9e9e9e",
                  color: "white",
                  fontSize: "14px",
                  fontWeight: "600",
                }}
              >
                {currentSession.status === "IN_PROGRESS"
                  ? "ƒêang s·∫°c"
                  : currentSession.status === "COMPLETED"
                  ? "Ho√†n th√†nh"
                  : currentSession.status === "FAILED"
                  ? "Th·∫•t b·∫°i"
                  : currentSession.status ?? "-"}
              </span>
            </p>
          </div>

          {/* Quick Info Cards */}
          <div
            className="quick-info-grid"
            style={{
              display: "grid",
              gridTemplateColumns: "repeat(auto-fit, minmax(250px, 1fr))",
              gap: "15px",
              marginBottom: "25px",
            }}
          >
            <div
              style={{
                background: "#f8f9fa",
                padding: "15px",
                borderRadius: "10px",
                border: "1px solid #e0e0e0",
              }}
            >
              <div
                style={{
                  fontSize: "14px",
                  color: "#666",
                  marginBottom: "8px",
                  display: "flex",
                  alignItems: "center",
                  gap: "6px",
                }}
              >
                üöó Th√¥ng tin xe
              </div>
              <div
                style={{ fontSize: "18px", fontWeight: "600", color: "#333" }}
              >
                {currentSession.vehiclePlate ?? "-"}
              </div>
            </div>

            <div
              style={{
                background: "#f8f9fa",
                padding: "15px",
                borderRadius: "10px",
                border: "1px solid #e0e0e0",
              }}
            >
              <div
                style={{
                  fontSize: "14px",
                  color: "#666",
                  marginBottom: "8px",
                  display: "flex",
                  alignItems: "center",
                  gap: "6px",
                }}
              >
                üè¢ Th√¥ng tin tr·∫°m
              </div>
              <div
                style={{ fontSize: "18px", fontWeight: "600", color: "#333" }}
              >
                {currentSession.stationName ?? "-"}
              </div>
            </div>

            <div
              style={{
                background: "#f8f9fa",
                padding: "15px",
                borderRadius: "10px",
                border: "1px solid #e0e0e0",
              }}
            >
              <div
                style={{
                  fontSize: "14px",
                  color: "#666",
                  marginBottom: "8px",
                  display: "flex",
                  alignItems: "center",
                  gap: "6px",
                }}
              >
                ‚è∞ B·∫Øt ƒë·∫ßu
              </div>
              <div
                style={{ fontSize: "16px", fontWeight: "600", color: "#333" }}
              >
                {currentSession.startTime
                  ? new Date(currentSession.startTime).toLocaleString("vi-VN", {
                      hour: "2-digit",
                      minute: "2-digit",
                      day: "2-digit",
                      month: "2-digit",
                    })
                  : "-"}
              </div>
            </div>
          </div>

          {/* Battery Progress Circle */}
          {currentSession.initialSoc != null && (
            <BatteryProgressCircle
              initialSoc={currentSession.initialSoc}
              energyKWh={currentSession.energyKWh ?? 0}
              capacity={batteryCapacity}
              isCharging={currentSession.status === "IN_PROGRESS"}
              virtualSoc={currentSession.virtualSoc}
            />
          )}

          {/* Key Metrics Grid */}
          <div
            className="info-card-grid"
            style={{
              display: "grid",
              gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))",
              gap: "15px",
              marginBottom: "30px",
            }}
          >
            <InfoCard
              icon="‚ö°"
              label="NƒÉng l∆∞·ª£ng ƒë√£ s·∫°c"
              value={(currentSession.energyKWh ?? 0).toFixed(2)}
              unit="kWh"
              color="#4caf50"
            />
            <InfoCard
              icon="‚è±Ô∏è"
              label="Th·ªùi l∆∞·ª£ng"
              value={(currentSession.durationMinutes ?? 0).toFixed(0)}
              unit="ph√∫t"
              color="#2196f3"
            />
            <InfoCard
              icon="‚ö°"
              label="C√¥ng su·∫•t s·∫°c"
              value={currentPower.toFixed(1)}
              unit="kW"
              color="#9c27b0"
            />
          </div>

          {/* SOC Info */}
          {currentSession.initialSoc != null && (
            <div
              style={{
                background: "#f8f9fa",
                padding: "20px",
                borderRadius: "12px",
                marginBottom: "30px",
                display: "flex",
                justifyContent: "space-around",
                flexWrap: "wrap",
                gap: "20px",
              }}
            >
              <div style={{ textAlign: "center" }}>
                <div
                  style={{
                    fontSize: "14px",
                    color: "#666",
                    marginBottom: "5px",
                  }}
                >
                  SOC Ban ƒë·∫ßu
                </div>
                <div
                  style={{ fontSize: "28px", fontWeight: "700", color: "#666" }}
                >
                  {currentSession.initialSoc}%
                </div>
              </div>
              <div
                style={{
                  width: "2px",
                  background: "#ddd",
                  margin: "0 10px",
                }}
              />
              <div style={{ textAlign: "center" }}>
                <div
                  style={{
                    fontSize: "14px",
                    color: "#666",
                    marginBottom: "5px",
                  }}
                >
                  SOC Hi·ªán t·∫°i
                </div>
                <div
                  style={{
                    fontSize: "28px",
                    fontWeight: "700",
                    color: "#00BFA6",
                  }}
                >
                  {/* ‚úÖ ∆Øu ti√™n finalSoc t·ª´ Backend (s·ªë nguy√™n) khi session completed */}
                  {currentSession.status === "COMPLETED" &&
                  currentSession.finalSoc != null
                    ? `${currentSession.finalSoc}%`
                    : `${(
                        currentSession.virtualSoc ??
                        Math.min(
                          currentSession.initialSoc +
                            ((currentSession.energyKWh ?? 0) /
                              getBatteryCapacity()) *
                              100,
                          100
                        )
                      ).toFixed(1)}%`}
                </div>
              </div>
              {currentSession.finalSoc != null && (
                <>
                  <div
                    style={{
                      width: "2px",
                      background: "#ddd",
                      margin: "0 10px",
                    }}
                  />
                  <div style={{ textAlign: "center" }}>
                    <div
                      style={{
                        fontSize: "14px",
                        color: "#666",
                        marginBottom: "5px",
                      }}
                    >
                      SOC Cu·ªëi
                    </div>
                    <div
                      style={{
                        fontSize: "28px",
                        fontWeight: "700",
                        color: "#2196f3",
                      }}
                    >
                      {currentSession.finalSoc}%
                    </div>
                  </div>
                </>
              )}
            </div>
          )}

          <div style={{ marginTop: "30px", display: "flex", gap: "15px" }}>
            <button
              onClick={fetchCurrentSession}
              style={{
                padding: "12px 24px",
                background: "#00BFA6",
                color: "white",
                border: "none",
                borderRadius: "8px",
                fontSize: "16px",
                fontWeight: "600",
                cursor: "pointer",
              }}
            >
              üîÑ L√†m m·ªõi
            </button>

            {currentSession.status === "IN_PROGRESS" && (
              <button
                onClick={handleStopSession}
                disabled={stopping}
                style={{
                  padding: "12px 24px",
                  background: stopping ? "#ccc" : "#f44336",
                  color: "white",
                  border: "none",
                  borderRadius: "8px",
                  fontSize: "16px",
                  fontWeight: "600",
                  cursor: stopping ? "not-allowed" : "pointer",
                }}
              >
                {stopping ? "ƒêang d·ª´ng..." : "üõë D·ª´ng phi√™n s·∫°c"}
              </button>
            )}
          </div>
        </div>
      ) : (
        <div
          style={{
            background: "#f5f5f5",
            padding: "20px",
            borderRadius: "12px",
            textAlign: "center",
          }}
        >
          <p style={{ color: "#666" }}>Kh√¥ng c√≥ phi√™n s·∫°c n√†o ƒëang ho·∫°t ƒë·ªông</p>
        </div>
      )}
    </div>
  );
}
